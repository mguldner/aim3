From 9564b8cf68952ceef4009a19bffbb599c5583e3a Mon Sep 17 00:00:00 2001
From: mguldner <mathieuguldner.emn@gmail.com>
Date: Tue, 12 May 2015 23:10:44 +0200
Subject: [PATCH 1/2] assignement1

---
 .../assignment1/AverageTemperaturePerMonth.java    | 184 ++++++++++++++++++++-
 .../assignment1/BookAndAuthorBroadcastJoin.java    | 130 ++++++++++++++-
 .../dima/aim3/assignment1/FilteringWordCount.java  |  23 ++-
 .../aim3/assignment1/PrimeNumbersWritable.java     |  23 ++-
 .../AverageTemperaturePerMonthTest.java            |  32 +---
 .../aim3/assignment1/BookAndAuthorJoinTest.java    |  38 +----
 .../aim3/assignment1/PrimeNumbersWritableTest.java |   4 +-
 7 files changed, 359 insertions(+), 75 deletions(-)

diff --git a/src/main/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonth.java b/src/main/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonth.java
index ff99bf6..b616421 100644
--- a/src/main/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonth.java
+++ b/src/main/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonth.java
@@ -20,22 +20,200 @@ package de.tuberlin.dima.aim3.assignment1;
 
 import de.tuberlin.dima.aim3.HadoopJob;
 import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.*;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mapreduce.Reducer;
+import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
+import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
 
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
 import java.util.Map;
+import java.util.StringTokenizer;
 
 public class AverageTemperaturePerMonth extends HadoopJob {
 
+  private static double minimumQual;
+
   @Override
   public int run(String[] args) throws Exception {
-    Map<String,String> parsedArgs = parseArgs(args);
+    Map<String, String> parsedArgs = parseArgs(args);
 
     Path inputPath = new Path(parsedArgs.get("--input"));
     Path outputPath = new Path(parsedArgs.get("--output"));
 
     double minimumQuality = Double.parseDouble(parsedArgs.get("--minimumQuality"));
+    minimumQual = minimumQuality;
 
-    //IMPLEMENT ME
+    Job averageTemp = prepareJob(inputPath, outputPath, TextInputFormat.class, AverageTempMapper.class,
+            YearAndMonth.class, TempAndQuality.class, AverageTempReducer.class, Text.class, DoubleWritable.class, TextOutputFormat.class);
+    averageTemp.waitForCompletion(true);
 
     return 0;
   }
-}
\ No newline at end of file
+
+  static class AverageTempMapper extends Mapper<Object, Text, YearAndMonth, TempAndQuality> {
+    @Override
+    protected void map(Object key, Text line, Context ctx) throws IOException, InterruptedException {
+      StringTokenizer st = new StringTokenizer(line.toString());
+      ctx.write(new YearAndMonth(Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())),
+              new TempAndQuality(Integer.parseInt(st.nextToken()), Double.parseDouble(st.nextToken())));
+    }
+  }
+
+  static class AverageTempReducer extends Reducer<YearAndMonth, TempAndQuality, Text, DoubleWritable> {
+    @Override
+    protected void reduce(YearAndMonth key, Iterable<TempAndQuality> values, Context ctx)
+            throws IOException, InterruptedException {
+      double tempAv = 0;
+      double number = 0;
+      for (TempAndQuality i : values) {
+        if (i.getQuality() > minimumQual) {
+          tempAv += i.getTemperature();
+          number++;
+        }
+      }
+      tempAv /= number;
+      ctx.write(new Text(key.toString()), new DoubleWritable(tempAv));
+    }
+  }
+}
+
+class TempAndQuality implements Writable {
+  private int temperature;
+  private double quality;
+
+  public TempAndQuality(){
+    this.temperature=0;
+    this.quality=0.0;
+  }
+
+  public TempAndQuality(int temperature, double quality) {
+    this.temperature = temperature;
+    this.quality = quality;
+  }
+
+  public double getQuality() {
+    return quality;
+  }
+
+  public int getTemperature() {
+    return temperature;
+  }
+
+  @Override
+  public void write(DataOutput out) throws IOException {
+    out.writeInt(this.temperature);
+    out.writeDouble(this.quality);
+  }
+
+  @Override
+  public void readFields(DataInput in) throws IOException {
+    this.temperature = in.readInt();
+    this.quality = in.readDouble();
+  }
+}
+
+class YearAndMonth implements WritableComparable {
+
+  private int year;
+  private int month;
+
+  public YearAndMonth(){
+    this.year=0;
+    this.month=0;
+  }
+
+  public YearAndMonth(int year, int month) {
+    this.year = year;
+    this.month = month;
+  }
+
+  public int getYear() {
+    return this.year;
+  }
+
+  public int getMonth() {
+    return month;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof YearAndMonth) {
+      YearAndMonth other = (YearAndMonth) o;
+      return year == other.year && month == other.month;
+    }
+    return false;
+  }
+
+  public void write(DataOutput out) throws IOException {
+    out.writeInt(this.year);
+    out.writeInt(this.month);
+  }
+
+  public void readFields(DataInput in) throws IOException {
+    this.year = in.readInt();
+    this.month = in.readInt();
+  }
+
+  public int compareTo(Object o) {
+    if (o instanceof YearAndMonth) {
+      YearAndMonth other = (YearAndMonth) o;
+      if (this.year == other.year)
+        return Integer.compare(this.month, other.month);
+      else
+        return Integer.compare(this.year, other.year);
+    } else return 1;
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * this.month + this.year;
+  }
+
+  @Override
+  public String toString() {
+    return this.year+"\t"+this.month;
+  }
+}
+
+/*class Month implements WritableComparable{
+  public int month;
+  public int year;
+
+  public Month(int year, int month){
+    this.month=month;
+    this.year=year;
+  }
+
+  public void write(DataOutput out) throws IOException {
+    out.writeInt(this.year);
+    out.writeInt(this.month);
+  }
+
+  public void readFields(DataInput in) throws IOException {
+    this.year = in.readInt();
+    this.month = in.readInt();
+  }
+
+  public int compareTo(Object o){
+    if(o instanceof Month) {
+      Month other = (Month)o;
+      if (this.year == other.year)
+        return Integer.compare(this.month, other.month);
+      else
+        return Integer.compare(this.year, other.year);
+    }
+    else return 0;
+  }
+
+  public boolean equals(Object o){
+    if(!(o instanceof  Month))
+      return false;
+
+    Month other = (Month)(o);
+    return (this.year==other.year && this.month==other.month);
+  }
+}*/
\ No newline at end of file
diff --git a/src/main/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorBroadcastJoin.java b/src/main/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorBroadcastJoin.java
index 0de1448..e144eda 100644
--- a/src/main/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorBroadcastJoin.java
+++ b/src/main/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorBroadcastJoin.java
@@ -18,25 +18,149 @@
 
 package de.tuberlin.dima.aim3.assignment1;
 
+import com.google.common.base.Preconditions;
 import de.tuberlin.dima.aim3.HadoopJob;
 import org.apache.hadoop.fs.Path;
+import org.apache.hadoop.io.IntWritable;
+import org.apache.hadoop.io.Text;
+import org.apache.hadoop.io.Writable;
+import org.apache.hadoop.mapred.lib.MultipleInputs;
+import org.apache.hadoop.mapreduce.Job;
+import org.apache.hadoop.mapreduce.Mapper;
+import org.apache.hadoop.mapreduce.Reducer;
+import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;
+import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
 
-import java.util.Map;
+import java.io.*;
+import java.util.*;
 
 public class BookAndAuthorBroadcastJoin extends HadoopJob {
+  public static HashMap<Integer, ArrayList<Book>> ht;
 
   @Override
   public int run(String[] args) throws Exception {
 
     Map<String,String> parsedArgs = parseArgs(args);
 
+    //Get the paths to the files
     Path authors = new Path(parsedArgs.get("--authors"));
     Path books = new Path(parsedArgs.get("--books"));
     Path outputPath = new Path(parsedArgs.get("--output"));
 
-    //IMPLEMENT ME
+    //Store the books in a HashMap
+    ht = new HashMap<Integer, ArrayList<Book>>();
+    BufferedReader br = null;
+    String line = null;
+    try {
+      //Read the file "books"
+      br = new BufferedReader(new FileReader(new File(books.toString())));
+      while ((line = br.readLine()) != null) {
+        //Parse the file and store the elements
+        StringTokenizer st = new StringTokenizer(line);
+        Integer index = Integer.parseInt(st.nextToken());
+        int bookYear = Integer.parseInt(st.nextToken());
+        String bookTitle="";
+
+        //Get the name of the book, the first caracter is a blank space
+        while (st.hasMoreTokens())
+          bookTitle+= " "+st.nextToken();
+        //Remove the blank space
+        bookTitle=bookTitle.substring(1);
+        Book actualBook = new Book(bookTitle, bookYear);
+
+        //If the key of the author is already stored, just add the book to the ArrayList
+        if(ht.containsKey(index)){
+          ht.get(index).add(actualBook);
+        }
+        //Else create the ArrayList for the author and put the pair
+        else {
+          ArrayList<Book> actualBooks = new ArrayList<Book>();
+          actualBooks.add(actualBook);
+          ht.put(index, actualBooks);
+        }
+      }
+    }catch (Exception e){
+      e.printStackTrace();
+    }
+
+    //Create the job
+    Job broadcastJoin = prepareJob(authors, outputPath, TextInputFormat.class, BroadcastJoinMapper.class,
+            Text.class, Book.class, BroadcastJoinReducer.class, Text.class, Book.class, TextOutputFormat.class);
+    /* Remove the reducer part */
+    broadcastJoin.setNumReduceTasks(0);
+    broadcastJoin.waitForCompletion(true);
 
     return 0;
   }
 
-}
\ No newline at end of file
+  static class BroadcastJoinMapper extends Mapper<Object, Text, Text, Book> {
+    @Override
+    protected void map(Object key, Text line, Context ctx) throws IOException, InterruptedException {
+      StringTokenizer st = new StringTokenizer(line.toString());
+      //Store the index and the corresponding author
+      Integer index = Integer.parseInt(st.nextToken());
+      String a="";
+      while(st.hasMoreTokens())
+        a+=" "+st.nextToken();
+      a=a.substring(1);
+      Text author = new Text(a);
+
+      //For every book of the author [index], add the pair (author, book)
+      for(Book b : ht.get(index))
+        ctx.write(author, b);
+    }
+  }
+
+  static class BroadcastJoinReducer extends Reducer<Text, Book, Text, Text> {
+    @Override
+    protected void reduce(Text key, Iterable<Book> values, Context ctx)
+            throws IOException, InterruptedException {
+      //No need of reduce function because all is done in the map function
+    }
+  }
+}
+
+// Object Book which implements the interface Writable
+class Book implements Writable{
+
+  private String title;
+  private int year;
+
+  public Book(){
+    this.title="";
+    this.year=0;
+  }
+  public Book(String title, int year) {
+    this.title = Preconditions.checkNotNull(title);
+    this.year = year;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o instanceof Book) {
+      Book other = (Book) o;
+      return title.equals(other.title) && year == other.year;
+    }
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * title.hashCode() + year;
+  }
+
+  @Override
+  public void write(DataOutput out) throws IOException {
+    out.writeInt(this.year);
+    out.writeChars(this.title);
+  }
+
+  @Override
+  public void readFields(DataInput in) throws IOException {
+  }
+
+  @Override
+  public String toString() {
+    return this.title + "\t" + this.year ;
+  }
+}
diff --git a/src/main/java/de/tuberlin/dima/aim3/assignment1/FilteringWordCount.java b/src/main/java/de/tuberlin/dima/aim3/assignment1/FilteringWordCount.java
index 2ad6bb6..68100e5 100644
--- a/src/main/java/de/tuberlin/dima/aim3/assignment1/FilteringWordCount.java
+++ b/src/main/java/de/tuberlin/dima/aim3/assignment1/FilteringWordCount.java
@@ -30,6 +30,7 @@ import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.StringTokenizer;
 
 public class FilteringWordCount extends HadoopJob {
 
@@ -50,7 +51,21 @@ public class FilteringWordCount extends HadoopJob {
   static class FilteringWordCountMapper extends Mapper<Object,Text,Text,IntWritable> {
     @Override
     protected void map(Object key, Text line, Context ctx) throws IOException, InterruptedException {
-      // IMPLEMENT ME
+      StringTokenizer st = new StringTokenizer(line.toString());
+      while(st.hasMoreTokens()) {
+        String word = st.nextToken().toLowerCase();
+        String[] stopWords = {"to", "and", "in", "the"};
+        boolean isStopWord = false;
+        for (int i = 0; i < stopWords.length; i++) {
+          if(word.equals(stopWords[i]))
+            isStopWord=true;
+        }
+        if (!isStopWord) {
+          if (word.charAt(word.length() - 1) < 97 || word.charAt(word.length() - 1) > 122)
+            word = word.substring(0, word.length() - 1);
+          ctx.write(new Text(word), new IntWritable(1));
+        }
+      }
     }
   }
 
@@ -58,7 +73,11 @@ public class FilteringWordCount extends HadoopJob {
     @Override
     protected void reduce(Text key, Iterable<IntWritable> values, Context ctx)
         throws IOException, InterruptedException {
-      // IMPLEMENT ME
+      int sum = 0;
+      for (IntWritable i : values) {
+        sum += i.get();
+      }
+      ctx.write(key, new IntWritable(sum));
     }
   }
 
diff --git a/src/main/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritable.java b/src/main/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritable.java
index 527801f..349b0b7 100644
--- a/src/main/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritable.java
+++ b/src/main/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritable.java
@@ -20,31 +20,40 @@ package de.tuberlin.dima.aim3.assignment1;
 
 import org.apache.hadoop.io.Writable;
 
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
+import java.io.*;
 import java.util.Arrays;
 
 public class PrimeNumbersWritable implements Writable {
 
   private int[] numbers;
+  private int numberOfNumbers;
 
   public PrimeNumbersWritable() {
     numbers = new int[0];
+    this.numberOfNumbers=0;
   }
 
   public PrimeNumbersWritable(int... numbers) {
     this.numbers = numbers;
+    this.numberOfNumbers=numbers.length;
+  }
+
+  public PrimeNumbersWritable(int numberOfNumbers) {
+    this.numberOfNumbers = numberOfNumbers;
+    this.numbers = new int[numberOfNumbers];
   }
 
   @Override
   public void write(DataOutput out) throws IOException {
-    //IMPLEMENT ME
+    for (int i : this.numbers)
+      out.writeInt(i);
   }
 
   @Override
   public void readFields(DataInput in) throws IOException {
-    //IMPLEMENT ME
+    for (int i = 0; i < this.numberOfNumbers; i++) {
+      this.numbers[i]=in.readInt();
+    }
   }
 
   @Override
@@ -60,4 +69,8 @@ public class PrimeNumbersWritable implements Writable {
   public int hashCode() {
     return Arrays.hashCode(numbers);
   }
+
+  public int getNumberOfNumbers(){
+    return this.numberOfNumbers;
+  }
 }
\ No newline at end of file
diff --git a/src/test/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonthTest.java b/src/test/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonthTest.java
index dec6fc0..269245f 100644
--- a/src/test/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonthTest.java
+++ b/src/test/java/de/tuberlin/dima/aim3/assignment1/AverageTemperaturePerMonthTest.java
@@ -56,35 +56,9 @@ public class AverageTemperaturePerMonthTest extends HadoopTestCase {
 
     Map<YearAndMonth, Double> results = readResults(new File(outputDir, "part-r-00000"));
 
-    assertEquals(results.get(new YearAndMonth(1990, 8)), 8, EPSILON);
-    assertEquals(results.get(new YearAndMonth(1992, 4)), 7.888d, EPSILON);
-    assertEquals(results.get(new YearAndMonth(1994, 1)), 8.24, EPSILON);
-  }
-
-
-  class YearAndMonth {
-
-    private final int year;
-    private final int month;
-
-    public YearAndMonth(int year, int month) {
-      this.year = year;
-      this.month = month;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof YearAndMonth) {
-        YearAndMonth other = (YearAndMonth) o;
-        return year == other.year && month == other.month;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return 31 * year + month;
-    }
+    assertEquals(8, results.get(new YearAndMonth(1990, 8)), EPSILON);
+    assertEquals(7.888d, results.get(new YearAndMonth(1992, 4)), EPSILON);
+    assertEquals(8.24, results.get(new YearAndMonth(1994, 1)), EPSILON);
   }
 
   private Map<YearAndMonth,Double> readResults(File outputFile) throws IOException {
diff --git a/src/test/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorJoinTest.java b/src/test/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorJoinTest.java
index 2370b6c..d44deac 100644
--- a/src/test/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorJoinTest.java
+++ b/src/test/java/de/tuberlin/dima/aim3/assignment1/BookAndAuthorJoinTest.java
@@ -60,17 +60,17 @@ public class BookAndAuthorJoinTest extends HadoopTestCase {
 
     bookAndAuthorJoin.setConf(conf);
     bookAndAuthorJoin.run(new String[] { "--authors", authorsFile.getAbsolutePath(),
-        "--books", booksFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath() });
+            "--books", booksFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath() });
+
+    String outputFilename = mapOnly? "part-m-00000" : "part-r-00000";
 
-    String outputFilename = mapOnly ? "part-m-00000" : "part-r-00000";
-    
     Multimap<String, Book> booksByAuthors = readBooksByAuthors(new File(outputDir, outputFilename));
 
     assertTrue(booksByAuthors.containsKey("Charles Bukowski"));
     assertTrue(booksByAuthors.get("Charles Bukowski")
-        .contains(new Book("Confessions of a Man Insane Enough to Live with Beasts", 1965)));
+            .contains(new Book("Confessions of a Man Insane Enough to Live with Beasts", 1965)));
     assertTrue(booksByAuthors.get("Charles Bukowski")
-        .contains(new Book("Hot Water Music", 1983)));
+            .contains(new Book("Hot Water Music", 1983)));
 
     assertTrue(booksByAuthors.containsKey("Fyodor Dostoyevsky"));
     assertTrue(booksByAuthors.get("Fyodor Dostoyevsky").contains(new Book("Crime and Punishment", 1866)));
@@ -83,36 +83,12 @@ public class BookAndAuthorJoinTest extends HadoopTestCase {
 
     Pattern separator = Pattern.compile("\t");
     for (String line : Files.readLines(outputFile, Charsets.UTF_8)) {
+      System.out.println(line);
       String[] tokens = separator.split(line);
       booksByAuthors.put(tokens[0], new Book(tokens[1], Integer.parseInt(tokens[2])));
     }
     return booksByAuthors;
   }
 
-
-  static class Book {
-
-    private final String title;
-    private final int year;
-
-    public Book(String title, int year) {
-      this.title = Preconditions.checkNotNull(title);
-      this.year = year;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-      if (o instanceof Book) {
-        Book other = (Book) o;
-        return title.equals(other.title) && year == other.year;
-      }
-      return false;
-    }
-
-    @Override
-    public int hashCode() {
-      return 31 * title.hashCode() + year;
-    }
-  }
-
 }
+
diff --git a/src/test/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritableTest.java b/src/test/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritableTest.java
index 17272ca..df25e04 100644
--- a/src/test/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritableTest.java
+++ b/src/test/java/de/tuberlin/dima/aim3/assignment1/PrimeNumbersWritableTest.java
@@ -48,10 +48,10 @@ public class PrimeNumbersWritableTest {
 
     DataInput in = new DataInputStream(new ByteArrayInputStream(buffer.toByteArray()));
 
-    PrimeNumbersWritable clone1 = new PrimeNumbersWritable();
+    PrimeNumbersWritable clone1 = new PrimeNumbersWritable(original1.getNumberOfNumbers());
     clone1.readFields(in);
 
-    PrimeNumbersWritable clone2 = new PrimeNumbersWritable();
+    PrimeNumbersWritable clone2 = new PrimeNumbersWritable(original2.getNumberOfNumbers());
     clone2.readFields(in);
 
     assertEquals(original1, clone1);
-- 
1.9.1

